" change the mapleader from \ to ,
let mapleader=","

if &shell =~# 'fish$'
    set shell=bash
endif

" vim-plug configuration
source $HOME/.bundles.vim

" File/Syntax settings
au FileType css     setlocal sw=2 sts=2
au FileType html    setlocal sw=2 sts=2
au FileType htmldjango  setlocal sw=2 sts=2
au FileType python  setlocal formatoptions-=t
au FileType yaml    setlocal sw=2 sts=2
au FileType javascript    setlocal sw=2 sts=2

augroup markdown
  au!
  au BufNewFile,BufRead *.md,*.markdown setlocal filetype=markdown
augroup END

" Highlight fenced code blocks
" ref: https://github.com/tpope/vim-markdown/commit/b2697b0adfe5428b86c8470a5f9d8da667bb2785
let g:markdown_fenced_languages = ['python', 'rust']

augroup json
  au!
  au BufNewFile,BufRead *.json setlocal filetype=json
augroup END

augroup nginx
  au!
  au BufNewFile,BufRead *.site,*.nginx.conf setlocal filetype=nginx
augroup END

augroup Dockerfile
  au!
  au BufNewFile,BufRead Dockerfile.* setlocal filetype=Dockerfile
augroup END

augroup vagrant
  au!
  au BufNewFile,BufRead Vagrantfile setlocal filetype=ruby
augroup END

" JavaScript
let javascript_enable_domhtmlcss=1

" Terraform
let g:terraform_fmt_on_save=1

" Rust
let g:rustfmt_autosave=1

" Fish
" Set up :make to use fish for syntax checking.
autocmd FileType fish compiler fish

" Don't use backup files when editing crontab on OS X
" ref: http://superuser.com/q/359580
autocmd filetype crontab setlocal nobackup nowritebackup

" Filetype detection for *.symlink files
" If a file begins with '#!/', let vim autodetect the filetype. Otherwise
" read 'linguist-language' from .gitattributes.
augroup symlink
  autocmd!
  autocmd BufRead,BufNewFile *.symlink
        \ if getline(1) !~ '#!/' |
        \ let &ft=split(system('git check-attr linguist-language '.shellescape(expand('%:p'))))[-1] |
        \ endif
augroup END

syntax on

set modeline
set modelines=0

set encoding=utf-8
set scrolloff=3
set showmode
set showcmd
set hidden
set wildmenu
set wildmode=list:longest
set visualbell
set ttyfast
set ruler
set backspace=indent,eol,start
set laststatus=2
" used by vim-gitgutter
set updatetime=100

" make searching not suck
nnoremap / /\v
xnoremap / /\v
set ignorecase
set smartcase
set gdefault
set incsearch
set showmatch
set hlsearch
noremap <leader><space> :noh<cr>:call clearmatches()<cr>

"makes j and k go by screen lines
nnoremap j gj
nnoremap k gk

" Mouse settings
set mouse=nv
if &term=~'rxvt'
  set ttymouse=urxvt
endif

set title

" syntastic
let g:syntastic_enable_signs=1
let g:syntastic_check_on_open=1

let g:syntastic_python_checkers=['flake8']
let g:syntastic_yaml_checkers = ['yamllint']
let syntastic_mode_map = { 'passive_filetypes': ['html'] }
" create the loc list so you can jump between errors with arrow keys
let g:syntastic_always_populate_loc_list = 1
" nav between syntastic results
nnoremap <up> :lprev<cr>zvzz
nnoremap <down> :lnext<cr>zvzz

" toggle paste mode
nmap <LocalLeader>pp :set paste!<cr>

" Add dashes to the list of 'word characters' for CSS files:
au Filetype css setlocal iskeyword+=-

" YES YES YES YES set autoread
set autoread

" Enable soft-wrapping for text files
autocmd FileType text,markdown,html,xhtml,eruby setlocal wrap linebreak nolist

" Resize splits when the window is resized
au VimResized * exe "normal! \<c-w>="

" Splits open in reasonable places
set splitright
set splitbelow

" color
if &term ==# 'xterm-kitty'
  " https://sw.kovidgoyal.net/kitty/faq.html#using-a-color-theme-with-a-background-color-does-not-work-well-in-vim
  let &t_ut=''
endif

if has('termcolors')
  set termguicolors
endif
set background=dark
colorscheme gruvbox

" gui
if has("gui_macvim")
  " set guifont=Ubuntu\ Mono\ derivative\ Powerline:h18
  " TODO: find a good patched font
  set guifont=Menlo:h18
endif

" vim-airline
" TODO: find a good patched font
" let g:airline_powerline_fonts=1
set laststatus=2 " Always show the statusline

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" find merge conflict markers
nmap <silent> <leader>fc <ESC>/\v^[<=>]{7}( .*\|$)<CR>

" git status
nmap <Leader>g :Gstatus<CR>gg<c-n>

" Remove any trailing whitespace that is in the file
autocmd BufRead,BufWrite * if ! &bin | silent! %s/\s\+$//ge | endif

" DEATH TO F1
map <F1> <Esc>
imap <F1> <Esc>

" fzf
nnoremap <C-p> :Files<Cr>

"" MAKE .swp~ AND .un~ FILES LESS ANNOYING
"" FROM <http://stackoverflow.com/a/9528322/609144>
" Save your backups to a less annoying place than the current directory.
" If you have .vim-backup in the current directory, it'll use that.
" Otherwise it saves it to ~/.vim-backup or . if all else fails.
if isdirectory($HOME . '/.vim-backup') == 0
  silent !mkdir -p ~/.vim-backup >/dev/null 2>&1
endif
set backupdir-=.
set backupdir+=.
set backupdir-=~/
set backupdir^=~/.vim-backup/
set backupdir^=./.vim-backup/
set backup

" Save your swp files to a less annoying place than the current directory.
" If you have .vim-swap in the current directory, it'll use that.
" Otherwise it saves it to ~/.vim-swap, ~/tmp or .
if isdirectory($HOME . '/.vim-swap') == 0
  silent !mkdir -p ~/.vim-swap >/dev/null 2>&1
endif
set directory=./.vim-swap//
set directory+=~/.vim-swap//
set directory+=~/tmp//
set directory+=.

if exists("+undofile")
  " undofile - This allows you to use undos after exiting and restarting
  " This, like swap and backups, uses .vim-undo first, then ~/.vim-undo
  " :help undo-persistence
  " This is only present in 7.3+
  if isdirectory($HOME . '/.vim-undo') == 0
    silent !mkdir -p ~/.vim-undo > /dev/null 2>&1
  endif
  set undodir=./.vim-undo//
  set undodir+=~/.vim-undo//
  set undofile
endif

" clam.vim
nnoremap ! :Clam<space>

" Unfuck my screen
noremap U :syntax sync fromstart<cr>:redraw!<cr>

" Scrollbinding
set scrollopt+=hor
nmap <LocalLeader>s :set scrollbind<cr>

" Change-inside-surroundings.vim
nmap <leader>cis :ChangeInsideSurrounding<cr>

" vim-commentary
nmap <leader>cc gcc
xmap <leader>cc gc

" highlight column after 'textwidth' (e.g. 99 in Rust), but default to 80
function! ColorColumn()
  if !exists('+colorcolumn')
    return
  endif

  if &textwidth > 0
    set colorcolumn=+1
  else
    set colorcolumn=80
  endif
endfunction
" Set the color column whenever we enter a buffer. This let us do things like
" ':e newfile.rs' and get 'colorcolumn=100' and ':e newfile.py' and get
" 'colorcolumn=80' all in the same session!
au BufEnter * call ColorColumn()

" Rainbow Parentheses
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare

" Treat underscore as word delimiter
set iskeyword-=_

" esckeys
" http://ksjoberg.com/vim-esckeys.html
set timeout timeoutlen=1000 ttimeoutlen=100

" Gundo
nnoremap <F5> :GundoToggle<CR>

" numbers.vim in vim 7.4+
if v:version >= 704
  set number
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Miscellaneous autocmds

" Thaks @eevee: <https://github.com/eevee/rc/commit/376f4d6d59301c496cb9100fb562528c391f6485>
" Automatically delete swapfiles older than the actual file.
" Look at this travesty.  vim already has this information but doesn't expose
" it, so I have to reparse the swap file.  Ugh.
function! s:SwapDecide()
python << endpython
import os
import struct

import vim

# Format borrowed from:
# https://github.com/nyarly/Vimrc/blob/master/swapfile_parse.rb
SWAPFILE_HEADER = "=BB10sLLLL40s40s898scc"
size = struct.calcsize(SWAPFILE_HEADER)
with open(vim.eval('v:swapname'), 'rb') as f:
    buf = f.read(size)
(
    id0, id1, vim_version, pagesize, writetime,
    inode, pid, uid, host, filename, flags, dirty
) = struct.unpack(SWAPFILE_HEADER, buf)

try:
    # Test whether the pid still exists.  Could get fancy and check its name
    # or owning uid but :effort:
    os.kill(pid, 0)
except OSError:
    # NUL means clean, \x55 (U) means dirty.  Yeah I don't know either.
    if dirty == b'\x00':
        # Appears to be from a crash, so just nuke it
        vim.command('let v:swapchoice = "d"')

endpython
endfunction

if has("python")
    augroup eevee_swapfile
        autocmd!
        autocmd SwapExists * call s:SwapDecide()
    augroup END
endif


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
